# 【XR-4】模拟赛

## 题目描述

X 校正在进行 CSP 前的校内集训。

一共有 $n$ 名 OIer 参与这次集训，教练为他们精心准备了 $m$ 套模拟赛题。

然而，每名 OIer 都有各自的时间安排，巧合的是，他们在接下来的 $k$ 天中都恰好有 $m$ 天有空打模拟赛。

为了方便管理，教练规定一个人必须按顺序打完 $m$ 套模拟赛题。

比如，小 X 在接下来的第 $2,3,5$ 天有空打模拟赛，那么他就必须在第 $2$ 天打第 $1$ 套模拟赛题，第 $3$ 天打第 $2$ 套模拟赛题，第 $5$ 天打第 $3$ 套模拟赛题。

教练需要为每一个人的每一次模拟赛做准备，为了减小工作量，如果在某一天有多个人打同一套模拟赛题，那么教练只需要在这一天准备一场使用这一套题的模拟赛即可。

你作为机房大佬，教练想请你帮他计算一下，他每天需要准备多少场模拟赛。

## 输入格式

第一行三个整数 $n,m,k$。

接下来 $n$ 行，每行 $m$ 个整数，第 $i$ 行第 $j$ 列的整数 $a_{i,j}$ 表示第 $i$ 个人在接下来的 $k$ 天中第 $j$ 个有空的日子为第 $a_{i,j}$ 天。

## 输出格式

一行 $k$ 个整数，第 $i$ 个整数表示接下来的第 $i$ 天教练需要准备的模拟赛场数。

## 样例 #1

### 样例输入 #1

```
1 3 5
2 3 5
```

### 样例输出 #1

```
0 1 1 0 1
```

## 样例 #2

### 样例输入 #2

```
6 3 7
2 3 4
2 5 7
3 5 7
1 3 5
5 6 7
1 2 3
```

### 样例输出 #2

```
1 2 3 1 3 1 1
```

## 样例 #3

### 样例输入 #3

```
10 10 20
2 3 4 8 9 11 12 16 17 18
2 3 6 10 12 13 14 15 19 20
1 3 7 10 11 13 14 15 17 19
1 2 4 6 7 9 15 17 19 20
2 3 5 6 9 11 14 16 19 20
1 2 3 8 9 10 11 12 15 19
1 4 6 7 9 12 13 17 18 19
1 7 8 9 10 11 13 15 18 20
1 5 6 7 8 9 13 16 18 19
4 5 7 10 11 13 14 17 18 20
```

### 样例输出 #3

```
1 2 2 3 2 2 4 3 3 3 3 4 2 1 3 1 2 2 2 1
```

## 提示

**本题采用捆绑测试。**

- Subtask 1（13 points）：$n = m = k = 1$。
- Subtask 2（24 points）：$n = 1$。
- Subtask 3（24 points）：$m = 1$。
- Subtask 4（39 points）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n,m,k \le 10^3$，$m \le k$，$1 \le a_{i,1} < a_{i,2} < \cdots < a_{i,m} \le k$。


解答：

十分惭愧，这个题又把我挡住了，但是其实根本问题在于这些题目的问题在于，循环哪个变量，哪里需要循环，每一遍循环需要干什么，保证这些情况下我们所做的遍历是有意义的，这样既避免了效率过低，又能思路明确，这里还是利用别人的题解充一下数，后面放我自己重写的go语言的解答

（原文链接：[题解 P5594 【【XR-4】模拟赛】 - Eason&#39;s 2nd Luogu Blog - 洛谷博客](https://www.luogu.com.cn/blog/EasonBlog2/P5594-Solution)）

```cpp
//这里复制过来会乱版，就我来自己写分析吧
//vis i，j标志着第i套试卷在第j天是否准备了 a i j 表示第i名学生 第j套试卷是在第a[i][j]天做的 这里全都是从1开始进行标志的
// tot是结果，也就是第i天需要准备i套试卷
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

int n, m, k, tot[1004], vis[1004][1004], a[1004][1004];

int main() {
    scanf("%d%d%d", &n, &m, &k);
    for(int i = 1; i <= n; ++i)
        for(int j = 1; j <= m; ++j)
            scanf("%d", &a[i][j]);
    for(int i = 1; i <= n; ++i) {
        for(int j = 1; j <= m; ++j) {
            if(!vis[j][a[i][j]]) { //如果第j天没有准备第a[i][j]套试卷
                vis[j][a[i][j]] = 1;
                tot[a[i][j]]++;
            }
        }
    }
    for(int i = 1; i <= k; ++i)
        printf("%d ", tot[i]);
    return 0;
}
```

接下来还是为了练习我的go语言，进行了重写

```cpp
package main

import "fmt"

var visit [1024][1024]int
var num [1024]int
var a [1024][1024]int

func main() {
	var n, m, k int
	fmt.Scanf("%d %d %d\n", &n, &m, &k)
	for i := 1; i <= n; i++ {
		var j int
		for j = 1; j <= m; j++ {
			fmt.Scanf("%d", &a[i][j]) //表示第i个人第j次考试在那一天进行
		}
		fmt.Scanf("%d\n", &a[i][j]) //由于go语言扫描的严格性质，这里接着往下执行
	}
	for i := 1; i <= n; i++ {
		for j := 1; j <= m; j++ {
			if visit[j][a[i][j]] == 0 {
				visit[j][a[i][j]] = 1
				num[a[i][j]]++
			}
		}
	}
	for i := 1; i <= k; i++ {
		fmt.Printf("%d ", num[i])
	}
}

```

好家伙，用go语言重构之后发现会TLE？
